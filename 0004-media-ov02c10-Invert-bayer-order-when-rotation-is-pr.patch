From 7e2da48fcb2b65d014ed80b74bc4a677910ecbd1 Mon Sep 17 00:00:00 2001
From: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date: Mon, 1 Sep 2025 21:14:25 +0100
Subject: [PATCH 04/11] media: ov02c10: Invert bayer order when rotation is
 present in dts

When we invert the sensor output the order of bayer bytes changes.
Replicate what has already been done for ov02a10 as a first pass.

Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
---
 drivers/media/i2c/ov02c10.c | 36 ++++++++++++++++++++++++++++++------
 1 file changed, 30 insertions(+), 6 deletions(-)

diff --git a/drivers/media/i2c/ov02c10.c b/drivers/media/i2c/ov02c10.c
index 103d00741..750047afb 100644
--- a/drivers/media/i2c/ov02c10.c
+++ b/drivers/media/i2c/ov02c10.c
@@ -394,6 +394,10 @@ struct ov02c10 {
 	/* MIPI lane info */
 	u32 link_freq_index;
 	u8 mipi_lanes;
+
+	/* Mode */
+	struct v4l2_mbus_framefmt fmt;
+	bool upside_down;
 };
 
 static inline struct ov02c10 *to_ov02c10(struct v4l2_subdev *subdev)
@@ -579,12 +583,18 @@ static int ov02c10_init_controls(struct ov02c10 *ov02c10)
 	return 0;
 }
 
-static void ov02c10_update_pad_format(const struct ov02c10_mode *mode,
+static void ov02c10_update_pad_format(struct v4l2_subdev *sd,
+				      const struct ov02c10_mode *mode,
 				      struct v4l2_mbus_framefmt *fmt)
 {
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
 	fmt->width = mode->width;
 	fmt->height = mode->height;
-	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	if (ov02c10->upside_down)
+		fmt->code = MEDIA_BUS_FMT_SGBRG10_1X10;
+	else
+		fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
 	fmt->field = V4L2_FIELD_NONE;
 }
 
@@ -717,7 +727,7 @@ static int ov02c10_set_format(struct v4l2_subdev *sd,
 	struct ov02c10 *ov02c10 = to_ov02c10(sd);
 	s32 vblank_def, h_blank;
 
-	ov02c10_update_pad_format(mode, &fmt->format);
+	ov02c10_update_pad_format(sd, mode, &fmt->format);
 	*v4l2_subdev_state_get_format(sd_state, fmt->pad) = fmt->format;
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
@@ -738,10 +748,15 @@ static int ov02c10_enum_mbus_code(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_state *sd_state,
 				  struct v4l2_subdev_mbus_code_enum *code)
 {
+	struct ov02c10 *ov02c10 = to_ov02c10(sd);
+
 	if (code->index > 0)
 		return -EINVAL;
 
-	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+	if (ov02c10->upside_down == true)
+		code->code = MEDIA_BUS_FMT_SGBRG10_1X10;
+	else
+		code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
 
 	return 0;
 }
@@ -753,7 +768,8 @@ static int ov02c10_enum_frame_size(struct v4l2_subdev *sd,
 	if (fse->index >= ARRAY_SIZE(supported_modes))
 		return -EINVAL;
 
-	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
+	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10 &&
+	    fse->code != MEDIA_BUS_FMT_SGBRG10_1X10)
 		return -EINVAL;
 
 	fse->min_width = supported_modes[fse->index].width;
@@ -767,7 +783,7 @@ static int ov02c10_enum_frame_size(struct v4l2_subdev *sd,
 static int ov02c10_init_state(struct v4l2_subdev *sd,
 			      struct v4l2_subdev_state *sd_state)
 {
-	ov02c10_update_pad_format(&supported_modes[0],
+	ov02c10_update_pad_format(sd, &supported_modes[0],
 				  v4l2_subdev_state_get_format(sd_state, 0));
 
 	return 0;
@@ -911,6 +927,7 @@ static void ov02c10_remove(struct i2c_client *client)
 static int ov02c10_probe(struct i2c_client *client)
 {
 	struct ov02c10 *ov02c10;
+	unsigned int rotation;
 	int ret;
 
 	ov02c10 = devm_kzalloc(&client->dev, sizeof(*ov02c10), GFP_KERNEL);
@@ -919,6 +936,13 @@ static int ov02c10_probe(struct i2c_client *client)
 
 	v4l2_i2c_subdev_init(&ov02c10->sd, client, &ov02c10_subdev_ops);
 
+	rotation = 0;
+	device_property_read_u32(&client->dev, "rotation", &rotation);
+	if (rotation == 180) {
+		ov02c10->upside_down = true;
+		ov02c10->fmt.code = MEDIA_BUS_FMT_SGBRG10_1X10;
+	}
+
 	/* Check HW config */
 	ret = ov02c10_check_hwcfg(&client->dev, ov02c10);
 	if (ret)
-- 
2.51.0

